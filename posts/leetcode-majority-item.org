#+BEGIN_COMMENT
.. title: LeetCode: Majority Item II
.. slug: leetcode-majority-item
.. date: 2023-10-06 18:06:58 UTC-05:00
.. tags: leetcode,practice
.. category: Practice
.. link: 
.. description: The "Majority Item II" problem from LeetCode.
.. type: text
.. status: 
.. updated: 
.. has_pseudocode: true
#+END_COMMENT
#+OPTIONS: ^:{}
#+TOC: headlines 2
#+PROPERTY: header-args :session ~/.local/share/jupyter/runtime/kernel-352d2996-f830-43d1-8e14-406f25c95e00-ssh.json

#+BEGIN_SRC python :results none :exports none
%load_ext autoreload
%autoreload 2
#+END_SRC
* The Problem
 - **Given:** An integer array of size /n/.
 - **Find:** All elements that appear more than $\frac{n}{3}$ times.

**Constraints:**

\[
1 \leq nums.length \leq 5 \times 10^4 \\
-10^9 \leq nums[i] \leq 10^9
\]

* Using Python Collections

1. Find $\frac{n}{3}$
2. Count all the element frequencies
3. Build a list of all the elemennts that occur frequently enough

** The Examples

These are the examples given with the problem.

#+begin_src python :results none
def frequency_floor(source: list) -> None:
    """print the n/3 for the source

    Args:
     source: collection with a length
    """
    print("n/3: {0: 2}".format(len(source)/3))
    return
#+end_src

*** Example One

#+begin_src python :results output :exports both
input_1 = [3, 2, 3]
expected_1 = [3]

frequency_floor(input_1)
#+end_src

#+RESULTS:
: n/3:  1.0

*** Example Two

#+begin_src python :results output :exports both
input_2 = [1]
expected_2 = [1]

frequency_floor(input_2)
#+end_src

#+RESULTS:
: n/3:  0.3333333333333333

*** Example Three

#+begin_src python :results output :exports both
input_3 = [1, 2]
expected_3 = [1, 2]

frequency_floor(input_3)
#+end_src

#+RESULTS:
: n/3:  0.6666666666666666

It looks like they don't expect you to use rounding.

*** Collected

#+begin_src python :results none
EXAMPLES = [(input_1, expected_1), (input_2, expected_2),
            (input_3, expected_3)]
#+end_src
** Using Counter

#+begin_src python :results none
# python
from collections import Counter
from random import randint
from timeit import timeit

import random

# pypi
from expects import contain_only, expect
#+end_src

#+begin_src python :results none
def using_counter(source: list, expected) -> list:
    """gets the output for the source

    Args:
     source: collection to filter
     expected: the expected output

    Returns:
     items in source that occur more than n/3 times
    """
    counts = Counter(source)
    lower_bound = len(source)/3
    output = [key for key, value in counts.items() if value > lower_bound]
    expect(output).to(contain_only(*expected))
    return output
#+end_src

*** Example 1
#+begin_src python :results output :exports both
print(using_counter(input_1, expected_1))
#+end_src

#+RESULTS:
: [3]

*** Example 2

#+begin_src python :results output :exports both
print(using_counter(input_2, expected_2))
#+end_src

#+RESULTS:
: [1]

*** Example 3

#+begin_src python :results output :exports both
print(using_counter(input_3, expected_3))
#+end_src

#+RESULTS:
: [1, 2]

*** Timeit

#+begin_src python :results none
def unexpected_counter(source: list) -> None:
   counts = Counter(source)
   lower_bound = len(source)/3
   output = [key for key, value in counts.items() if value > lower_bound]
   return output

for source, expected in EXAMPLES:
   expect(unexpected_counter(source)).to(contain_only(*expected))
#+end_src

#+begin_src python :results output :exports both
LIMIT = 10**9
SIZE = 10**3
CANDIDATES = 3
SOURCE = [randint(-LIMIT, LIMIT) for item in range(CANDIDATES)]
BIG_INPUT = random.choices(SOURCE, k=SIZE)
print(Counter(BIG_INPUT).most_common())
print(SIZE/3)
#+end_src

#+RESULTS:
: [(-268262472, 343), (-963976892, 329), (628939969, 328)]
: 333.3333333333333

#+begin_src python :results output :exports both
counter_time = timeit("unexpected_counter(BIG_INPUT)", globals=globals())
print("Time with Counter: {0:.2}".format(counter_time))
#+end_src

#+RESULTS:
: Time with Counter: 2e+01

#+begin_src python :results output :exports both
uncounter_time = timeit("""
counts = Counter(BIG_INPUT)
lower_bound = len(BIG_INPUT)/3
output = [key for key, value in counts.items() if value > lower_bound]
""", globals=globals())
print("Time with Un-Functioned Counter: {0:.2}".format(uncounter_time))
#+end_src

#+RESULTS:
: Time with Un-Functioned Counter: 2e+01

#+begin_src python :results output :exports both
print(counter_time - uncounter_time)
#+end_src

#+RESULTS:
: -0.013954381982330233

#+begin_src python :results output :exports both
counter_output = unexpected_counter(BIG_INPUT)
print(counter_output)
#+end_src

#+RESULTS:
: [-268262472]

** Without Imports
#+begin_src python :results none
def without_imports(source: list, expected: list) -> list:
    """filters out items with too few occurrences

    Args:
     source: collection to filter
     expected: expected output

    Returns:
     filtered list
    """
    lower_bound = len(source)/3
    counts = {key: 0 for key in source}
    for item in source:
        counts[item] += 1

    output = [item for item, count in counts.items()
              if count > lower_bound]
    expect(output).to(contain_only(*expected))
    return output
#+end_src

*** Examples

#+begin_src python :results none
for example, expected in EXAMPLES:
    without_imports(example, expected)
#+end_src

*** Time It

#+begin_src python :results none
def unexpected_dictionary(source):
    lower_bound = len(source)/3
    counts = {key: 0 for key in source}
    
    for item in source:
        counts[item] += 1

    return [item for item, count in counts.items()
              if count > lower_bound]

for source, expected in EXAMPLES:
    expect(unexpected_dictionary(source)).to(contain_only(*expected))
#+end_src

#+begin_src python :results output :exports both
importless_time = timeit("unexpected_dictionary(BIG_INPUT)", globals=globals())
print("Time without Counter: {0:.2}".format(importless_time))
#+end_src

#+RESULTS:
: Time without Counter: 1.9e+01

#+begin_src python :results output :exports both
print(counter_time - importless_time)
unexpected_output = unexpected(BIG_INPUT)
expect(unexpected_output).to(contain_only(*counter_output))
#+end_src

#+RESULTS:
: 0.7523003370151855

Strangely this was a little faster. When there were a lot of different numbers in the ~BIG_INPUT~ the ~Counter~ version was faster, but with only three they're pretty much the same. But, when there were a lot of different numbers, since the ~random.choices~ is using a uniform distribution there was also never a case that had more than a third of the list either, so it wasn't really a good input.

** Reducing the Counter Lines

#+begin_src python :results output :exports both
re_uncounter_time = timeit("""
output = [key for key, value in Counter(BIG_INPUT).items()
if value > len(BIG_INPUT)/3]
""", globals=globals())
print("Time with Un-Rolled-Functioned Counter: {0:.2}".format(re_uncounter_time))
#+end_src

#+RESULTS:
: Time with Un-Rolled-Functioned Counter: 2e+01

#+begin_src python :results output :exports both
print(counter_time - re_uncounter_time)
#+end_src

#+RESULTS:
: -0.01702814898453653

 The single comprehension is a little slower than the function (although not noticeably).

#+begin_src python :results output :exports both
print(re_uncounter_time - importless_time)
#+end_src

#+RESULTS:
: 0.769328485999722

* Majority Vote and Heavy Hitters Algorithms

On the discussion board for [[https://leetcode.com/problems/majority-element-ii/][the Majority Element II problem on LeetCode]] there's several people who mention the [[https://en.wikipedia.org/w/index.php?title=Boyer%E2%80%93Moore_majority_vote_algorithm&oldid=1173091113][Boyer-Moore Majority Vote Algorithm]] which is a [[https://en.wikipedia.org/w/index.php?title=Streaming_algorithm&oldid=1172213699][Streaming Algorithm]]
to find the element with the majority of the places in a sequence. Since it's a streaming algorithm it doesn't build a dictionary (or Counter) like I did but instead uses two passes over the sequence keeping the majority element in a variable. This is the algorithm given on Wikipedia.

#+begin_export html
<pre id="boyer-moore"  class="pseudocode">
\begin{algorithm}
\caption{Boyer-Moore Majority Voting Algorithm}
\begin{algorithmic}
\INPUT A collection of votes
\OUTPUT The candidate that might have the majority
\PROCEDURE{MajorityVote}{\(votes\)}
  \STATE \(lead \gets 0\)
  \STATE $candidate \gets None$
  \FOR {$vote \in votes$}
   \IF {$lead = 0$}
    \STATE $candidate \gets vote$
    \STATE $lead \gets 1$
  \ELSEIF {$candidate$ = vote}
    \STATE $lead \gets lead + 1$
  \ELSE
    \STATE $lead \gets lead - 1$
   \ENDIF
  \ENDFOR
\RETURN candidate
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
</pre>
#+end_export

There is some kind of race condition that kills the math in the pseudocode if you reload the page without clearing the browser cache.

* Reference

-  Boyer–Moore majority vote algorithm. In: Wikipedia [Internet]. 2023 [cited 2023 Oct 9]. Available from: https://en.wikipedia.org/w/index.php?title=Boyer%E2%80%93Moore_majority_vote_algorithm&oldid=1173091113

- Misra–Gries heavy hitters algorithm. In: Wikipedia [Internet]. 2023 [cited 2023 Oct 9]. Available from: https://en.wikipedia.org/w/index.php?title=Misra%E2%80%93Gries_heavy_hitters_algorithm&oldid=1163180121

- Streaming algorithm. In: Wikipedia [Internet]. 2023 [cited 2023 Oct 9]. Available from: https://en.wikipedia.org/w/index.php?title=Streaming_algorithm&oldid=1172213699

 - https://leetcode.com/problems/majority-element-ii/ : The Majority Element Problem on LeetCode

#+begin_export html
<script>
window.addEventListener('load', function () {
    /* pseudocode.renderElement(document.getElementById("boyer-moore")); */
    pseudocode.renderClass("pseudocode");
});
</script>
#+end_export
