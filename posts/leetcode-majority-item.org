#+BEGIN_COMMENT
.. title: LeetCode: Majority Item II
.. slug: leetcode-majority-item
.. date: 2023-10-06 18:06:58 UTC-05:00
.. tags: leetcode,practice
.. category: Practice
.. link: 
.. description: The "Majority Item II" problem from LeetCode.
.. type: text
.. status: 
.. updated: 
.. has_pseudocode: true
#+END_COMMENT
#+OPTIONS: ^:{}
#+TOC: headlines 2
#+PROPERTY: header-args :session ~/.local/share/jupyter/runtime/kernel-5a57db02-c7c6-46fd-bcb6-cf4d7a9e01b8-ssh.json

#+BEGIN_SRC python :results none :exports none
%load_ext autoreload
%autoreload 2
#+END_SRC
* The Problem
 - **Given:** An integer array of size /n/.
 - **Find:** All elements that appear more than $\frac{n}{3}$ times.

**Constraints:**

\[
1 \leq nums.length \leq 5 \times 10^4 \\
-10^9 \leq nums[i] \leq 10^9
\]

* Using Python Collections

1. Find $\frac{n}{3}$
2. Count all the element frequencies
3. Build a list of all the elemennts that occur frequently enough

** Imports

#+begin_src python :results none
# python
from collections import Counter
from functools import partial
from random import randint
from timeit import timeit
from typing import List

import random

# pypi
from expects import contain_only, expect
from tabulate import tabulate

import altair
import pandas

# monkey brain
from graeae.visualization.altair_helpers import output_path, save_chart
#+end_src

#+begin_src python :results none
SLUG = "leetcode-majority-item"
OUTPUT_PATH = output_path(SLUG)
save_it = partial(save_chart, output_path=OUTPUT_PATH, height=650)

TABLE = partial(tabulate, headers="keys", showindex=False, tablefmt="orgtbl")
#+end_src

** The Examples

These are the examples given with the problem.

#+begin_src python :results none
def frequency_floor(source: list) -> None:
    """print the n/3 for the source

    Args:
     source: collection with a length
    """
    print("n/3: {0: 2}".format(len(source)/3))
    return
#+end_src

*** Example One

#+begin_src python :results output :exports both
input_1 = [3, 2, 3]
expected_1 = [3]

frequency_floor(input_1)
#+end_src

#+RESULTS:
: n/3:  1.0

*** Example Two

#+begin_src python :results output :exports both
input_2 = [1]
expected_2 = [1]

frequency_floor(input_2)
#+end_src

#+RESULTS:
: n/3:  0.3333333333333333

*** Example Three

#+begin_src python :results output :exports both
input_3 = [1, 2]
expected_3 = [1, 2]

frequency_floor(input_3)
#+end_src

#+RESULTS:
: n/3:  0.6666666666666666

It looks like they don't expect you to use rounding.

*** Collected

#+begin_src python :results none
EXAMPLES = [(input_1, expected_1), (input_2, expected_2),
            (input_3, expected_3)]

def test_examples(tester):
    """Checks if the tester gives the right answer

    Args:

     tester: callable that takes votes and returns candidates thtat pass

    Raises:

      AssertionError if callable returns the wrong candidates
    """
    for example, expected in EXAMPLES:
        expect(tester(example)).to(contain_only(*expected))
    return
#+end_src

*** A Bigger Input

#+begin_src python :results output :exports both
LIMIT = 10**9
SIZE = 10**3
CANDIDATES = 3
SOURCE = [randint(-LIMIT, LIMIT) for item in range(CANDIDATES)]
BIG_INPUT = random.choices(SOURCE, k=SIZE)
counts = Counter(BIG_INPUT).most_common()
print(counts)
LOWER_BOUND = len(BIG_INPUT)/3
print(LOWER_BOUND)

BIG_EXPECTED = [candidate for candidate, count in counts if count > LOWER_BOUND]
print(BIG_EXPECTED)

def test_expected(tester):
    """Test the tester against the examples and big input

    Args:

      tester: callable that takes votes as input and returns passing candidates

    Raises:

     AssertionError: callable returned the unexpected
    """
    test_examples(tester)
    expect(tester(BIG_INPUT)).to(contain_only(*BIG_EXPECTED))
    return
#+end_src

#+RESULTS:
: [(-863687885, 349), (923059645, 327), (-201695955, 324)]
: 333.3333333333333
: [-863687885]

** Using Counter

#+begin_src python :results none
def using_counter(source: List[int]) -> list:
    """gets the output for the source

    Args:
     source: collection to filter

    Returns:
     items in source that occur more than n/3 times
    """
    return [key for key, value in Counter(source).items() if value > len(source)/3]

test_expected(using_counter)
#+end_src

*** Timeit

#+begin_src python :results none
def time_it(callable_name: str) -> float:
    """Runs timeit on the callable and the BIG_INPUT

    Args:
      callable_name: name of the majority vote code to test

    Returns:
      timeit output
    """
    timed = timeit("{0}(BIG_INPUT)".format(callable_name), globals=globals())
    print("Time using {0}: {1:.2}".format(callable_name, timed))
    return timed
#+end_src

#+begin_src python :results output :exports both
counter_time = time_it("using_counter")
#+end_src

#+RESULTS:
: Time using using_counter: 2.1e+01

#+begin_src python :results output :exports both
counter_output = using_counter(BIG_INPUT)
print(counter_output)
#+end_src

#+RESULTS:
: [-863687885]

#+begin_src python :results none
def time_and_check(test_function) -> float:
    """Time, test, and check function against counter output

    Args:
      test_callable: majority element function to check

    Returns:
      timeit output for the function
    """
    test_expected(test_function)
    expect(test_function(BIG_INPUT)).to(contain_only(*counter_output))
    timed = time_it(test_function.__name__)
    print("Counter Time - {0}: {1:.2}".format(test_function.__name__, counter_time - timed))
    return timed
#+end_src
** Without Imports

#+begin_src python :results ouput :exports botht
def using_dictionary(source: List[int]) -> List[int]:
    """filters out items with too few occurrences

    Args:
     source: collection to filter

    Returns:
     filtered list
    """
    lower_bound = len(source)/3

    counts = dict()
    for item in source:
            counts[item] = counts.setdefault(item, 0) + 1
    return [item for item, count in counts.items()
              if count > lower_bound]

dictionary_time = time_and_check(using_dictionary)
#+end_src

#+RESULTS:
: Time using using_dictionary: 2e+01
: Counter Time - using_dictionary: 0.76

The times don't seem to be consistent, sometimes the Counter version is faster, sometimes when I run it the dict version is faster... I think it's more dependent on what's going on with the computer.

* Majority Vote and Heavy Hitters Algorithms

On the discussion board for [[https://leetcode.com/problems/majority-element-ii/][the Majority Element II problem on LeetCode]] there's several people who mention the [[https://en.wikipedia.org/w/index.php?title=Boyer%E2%80%93Moore_majority_vote_algorithm&oldid=1173091113][Boyer-Moore Majority Vote Algorithm]] which is a [[https://en.wikipedia.org/w/index.php?title=Streaming_algorithm&oldid=1172213699][Streaming Algorithm]]
to find the element with the majority of the places in a sequence. Since it's a streaming algorithm it doesn't build a dictionary (or Counter) like I did but instead uses two passes over the sequence keeping the majority element in a variable. This is the algorithm given on Wikipedia.

#+begin_export html
<pre id="boyer-moore" class="pseudocode">
\begin{algorithm}
\caption{Boyer-Moore Majority Voting Algorithm}
\begin{algorithmic}
\INPUT A collection of votes with a candidate with the majority of votes
\OUTPUT The candidate that might have the majority
\PROCEDURE{MajorityVote}{\textit{votes}}
  \STATE \textit{lead} $\gets 0$
  \STATE \textit{candidate} $\gets$ \textit{None}
  \FOR {\textit{vote} $\in$ \textit{votes}}
   \IF {\textit{lead = 0}}
    \STATE \textit{candidate} $\gets$ \textit{vote}
    \STATE \textit{lead} $\gets 1$
  \ELSEIF {\textit{candidate = vote}}
    \STATE \textit{lead} $\gets$ \textit{lead + 1}
  \ELSE
    \STATE \textit{lead} $\gets$ \textit{lead - 1}
   \ENDIF
  \ENDFOR
\RETURN \textit{candidate}
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
</pre>
#+end_export

**Note to self:** There is some kind of race-condition going on between ~pseudocode.js~ and ~MathJax~ which causes the math to not be rendered some times. Reloading the page or emptying the browser cache seems to fix it.

An important thing to note is that this only works if one of the candidates has more than half of the votes (the majority), not necessarily the most votes. If none of the candidates has more than half of the votes it might return not just the highest vote getter but any candidate. Consider this set.

\[
\{A, A, B, B, C, A\}
\]

| Vote | Candidate | Lead |
|------+-----------+------|
| A    | A         |    1 |
| A    | A         |    2 |
| B    | A         |    1 |
| B    | A         |    0 |
| C    | C         |    1 |
| A    | C         | 0    |

A has the most votes, but not greater than half and it ends up returning C as the leading candidate. Adding another A in there at any point would give it the majority and we would always return A.

One way to think of it is to consider that when the lead goes to zero it is essentially the same as resetting the algorithm and starting at the next vote - if the count goes to 0, none of the candidates had more votes than any other up to that point, so if there is an element that has the majority it will have to have it in the votes that follow. But if the candidate with the most votes doesn't have more than half of the total then it's possible that the other votes will negate it before reaching the end and we end up choosing the wrong candidate as the winner.

Another thing to note is that we are keeping a single counter so we don't know how many votes the eventual winner got. We could start a counter when a candidate takes the lead, but unless the eventual winner is always in the lead we'd end up skipping votes everytime the lead went to 0 and the leading candidate was swapped out.

So why not keep counts for all the candidates? That's what I did with the Counter and dict versions of our /Majority Items/ problem, but the Streaming Algorithms are meant to solve problems using a minimum of memory, something that the collections don't do. So instead, once we find our leading candidate on our first pass through the votes, we need to run a second pass to count up the number of votes the chosen candidate got to make sure it was the majority. If it wasn't, then the algorithm won't work so we don't have an answer.

** The Misra-Gries Heavy-Hitters Algorithm

One thing noticeable about the Boyer-Moore Voting Algorithm is that since it only works if one candidate gets more than half of the votes, then it doesn't really work for our problem, since we're looking for the candidates that get more than a third of the votes. The Heavy Hitters problem is an extension of the Majority Vote problem where instead of finding the candidate with more than half of the votes we find all candidates with greater than \(^n/_k\)votes where \(k \geq 2\) and the /Misra-Gries Heavy Hitters Algorithm/ is one way to solve it.

It works by maintaining a collection (/bag/) that holds the votes for the candidates that might have greater than \(^n/_k\) votes. This might seem like we're back to where we were with the dict, but the way the algorithm is constructed, the collection never holds more than /k/ distinct candidates (although it does keep track of their votes). Like the Boyer-Moore algorithm the Misra-Gries algorithm needs a seconds pass to determine which candidates actually have enough votes to be a heavy-hitter.

The output of the first pass is useful by itself, even if it doesn't completely solve the Heavy-Hitters problem, since it's constructed in a way so that the collection we're making will have the /k - 1/ candidates with the most votes.

Here's my slight re-wording of the algorithm as given on wikipedia.

#+begin_export html
<pre id="misra-gries" class="pseudocode">
\begin{algorithm}
\caption{Misra-Gries Heavy-Hitter Algorithm}
\begin{algorithmic}
\INPUT A collection of \textit{votes}
\INPUT $k$, the upper limit for candidates to output
\OUTPUT The $k - 1$ candidates that might be heavy hitters
\PROCEDURE{HeavyHitters}{\textit{votes}}
  \STATE \textit{distinct} $\gets 0$
  \STATE \textit{candidates} $\gets$ \{\}
  \FOR {\textit{vote} $\in$ \textit{votes}}
  
    \STATE Add \textit{candidate} to \textit{candidates}
    
    \IF {\textit{candidate} $\notin$ \textit{candidates}}
      \STATE \textit{distinct = distinct + 1}
   \ENDIF

   \IF {\textit{distinct} = $k$}
      \STATE Remove $k$ distinct elements from \textit{candidates}
      \STATE Update \textit{distinct}
   \ENDIF
  \ENDFOR
\RETURN \textit{candidates}
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
</pre>
#+end_export

So, here's some things to note about the algorithm:

 - $\textit{distinct}$ is the number of unique canditates in $\textit{candidates}$ (we're adding each vote so $candidates$ is larger than $\textit{distinct})$
 - $\textit{distinct}$ only gets incremented when we encounter a new candidate, and if $\textit{distinct} = k$ when we remove $k$ elements from $\textit{candidates}$ the last candidate only has one entry, so it gets removed
 - Update $\textit{distinct}$ is a little vague
 - Since we're storing all votes, doesn't that mean we're going to use a lot of memory? Why not just go with the earlier non-streaming solutions?

The answer to the vagueness of /Update distinct/ and the size of our /candidates/ is that we don't implement it exactly this way (and there's more than one way to implement it). Instead of storing all the votes, we can just store the counts of the votes (since that's all we care about anyway) along with the value that's being counted. Then we remove any value/count pair where the count has dropped to zero and reduce /distinct/ when we do. Since key-value pairs are natural for a dictionary we could implement it that way, knowing that it won't have more than /k-1/ keys and more than one value each.

An even better solution might be to create a collection of ( candidate, count ) tuples, but for our particular problem, there's an even better way.

** Python Implementation
#+begin_src python :results none
def misra_gries(votes: List[int]) -> tuple[int, int]: 
    """find the summary for the source

    Args:
     votes: list of votes for candidates

    Returns:
     top two potential candidates
    """
    candidate_1, candidate_2, count_1, count_2 = None, None, 0, 0

    for vote in votes:
        if vote == candidate_1:
            count_1 += 1
        elif vote == candidate_2:
            count_2 += 1
        elif count_1 == 0:
            candidate_1 = vote
            count_1 = 1
        elif count_2 == 0:
            candidate_2 = vote
            count_2 = 1
        else:
            count_1 -= 1
            count_2 -= 1

    return (candidate_1, candidate_2)
#+end_src

This first function only returns the summaries (the potential candidates). You could put the second pass in the function as well, but I thought it might be useful to see the output of the first pass.

#+begin_src python :results output :exports both
for index, (example, expected) in enumerate(EXAMPLES):
    print("Example: {}".format(index + 1))
    print("\tExpected: {}".format(expected))
    print("\tActual: {}\n".format(misra_gries(example)))

print("Big Input")
print("\tExpected: {}".format(counter_output))
print("\tActual: {}".format(misra_gries(BIG_INPUT)))
#+end_src

#+RESULTS:
#+begin_example
Example: 1
	Expected: [3]
	Actual: (3, 2)

Example: 2
	Expected: [1]
	Actual: (1, None)

Example: 3
	Expected: [1, 2]
	Actual: (1, 2)

Big Input
	Expected: [-863687885]
	Actual: (-863687885, 923059645)
#+end_example

So it got the last two right, but put in an extra candidate in the first case and the random example.

** The Second Pass

#+begin_src python :results output :exports both
def heavy_hitters(votes: list[int]) -> list[int]:
    """Finds candidates with over a third of the votes

    Args:
     votes: list of votes for candidates

    Returns:
      list of candidates with over a third of the votes
    """
    candidate_1, candidate_2 = misra_gries(votes)
    count_1 = count_2 = 0
    
    for vote in votes:
        if vote == candidate_1:
            count_1 += 1
        elif vote == candidate_2:
            count_2 += 1

    include_1 = count_1 > len(votes)/3
    include_2 = count_2 > len(votes)/3
    
    return [
        candidate for candidate, include in (
            (candidate_1, include_1), (candidate_2, include_2))
        if include]

heavy_time = time_and_check(heavy_hitters)
#+end_src

#+RESULTS:
: Time using heavy_hitters: 9.5
: Counter Time - heavy_hitters: 1.1e+01

Well, it looks like the heavy-hitters was a bit faster...

** A LeetCode Submission

#+begin_src python :results none
class Solution:
    def majorityElement(self, nums: List[int]) -> List[int]:
        candidate_1 = candidate_2 = None
        count_1 = count_2 = 0

        # misra_gries
        for vote in nums:
            if vote == candidate_1:
                count_1 += 1
            elif vote == candidate_2:
                count_2 += 1
            elif candidate_1 is None:
                candidate_1 = vote
                count_1 = 1
            elif candidate_2 is None:
                candidate_2 = vote
                count_2 = 1
            else:
                count_1 -= 1
                count_2 -= 1

                if count_1 == 0:
                    candidate_1 = None
                if count_2 == 0:
                    candidate_2 = None
                    
        # second pass
        count_1 = count_2 = 0
    
        for vote in nums:
            if vote == candidate_1:
                count_1 += 1
            elif vote == candidate_2:
                count_2 += 1
    
        return [
            candidate for candidate, heavy_hitter in (
                (candidate_1, count_1 > len(nums)/3),
                (candidate_2, count_2 > len(nums)/3))
            if heavy_hitter]

submission = Solution()
test_expected(submission.majorityElement)
#+end_src

Weirdly, in LeetCode it runs slighly slower (7 milliseconds, so about the same, really) and takes up slightly more memory (0.1 MB) than the dictionary version did. Something seems odd about their measurements, why would the dictionary take up less memory?

** The Lowest Memory Solution

Okay, I'm a little torn about this, but the submissions that use up the lowest memory on LeetCode seem to either use a Counter, like I did at first or they used the python ~list.count~ method, which works, but it seems, like the Counter, to be kind of a cheat, although I guess my use of ~len(votes)~ isn't that far off. Anyway.

#+begin_src python :results output :exports both
def using_list_count(votes: list[int]) -> list[int]:
    """finds the candidates with more than a third of the votes

    Args:
     votes: collection of candidate votes

    Returns:
      candidates that got more than a third of the vote
    """
    return [candidate for candidate in set(votes)
            if votes.count(candidate) > len(votes)/3]

list_count_time = time_and_check(using_list_count)
#+end_src

#+RESULTS:
: Time using using_list_count: 1.3e+01
: Counter Time - using_list_count: 7.1

Weirdly the Counter in my code is always slower but some of the fastest (and lowest memory) solutions on LeetCode use Counter. Maybe it's a pypy versus cPython thing.

This version does about the same as the dictionary solution on LeetCode (actually I accidentally returned a generator instead of a list and it did even better, but I suppose that violates the problem statement) so between the two of them they're the best ones. The dictionary did 1 millisecond better, but that seems too small a difference to matter. If I were to think of this as a translate the problem statement to python problem I would probably go with this, even though the Counter was what first came to mind, and the dict version doesn't require remembering list methods.

#+begin_src python :results output :exports both
def dict_list_counts(votes: list[int]) -> list[int]:
    """finds the candidates with more than a third of the votes

    Args:
     votes: collection of candidate votes

    Returns:
      candidates that got more than a third of the vote
    """
    lower_bound = len(votes)/3
    vote_counts = {vote: 0 for vote in votes}
    vote_counts = {vote: votes.count(vote) for vote in vote_counts}
    return [candidate for candidate in vote_counts
            if vote_counts[candidate] > lower_bound]

dict_list_time = time_and_check(dict_list_counts)
#+end_src

#+RESULTS:
: Time using dict_list_counts: 1.7e+01
: Counter Time - dict_list_counts: 3.2

So this was a little faster than uisng the dictionary and a for loop but slower than the Heavy Hitters or the /set/ version in ~using_list_count~

* Comparing The Times

#+begin_src python :results output :exports both
times = pandas.DataFrame(dict(Function=["Using Counter",
                                        "Using Dictionary",
                                        "Heavy Hitters",
                                        "Using List Count",
                                        "Dict List Counts"],
                              Time=[counter_time,
                                    dictionary_time,
                                    heavy_time,
                                    list_count_time,
                                    dict_list_time]))

times = times.sort_values("Time")

chart = altair.Chart(times).mark_bar().encode(
    x = altair.X("Function",
                 sort="-y"
                 ).axis(labelAngle=-45),
    y = "Time",
    tooltip = [altair.Tooltip("Function"),
               altair.Tooltip("Time", format=".2f")]
    
).interactive().properties(
    title="Function Timeit Times",
    width=800,
    height=525,
)

save_it(chart, "function_timeits")
#+end_src

#+RESULTS:
#+begin_export html
<object type="text/html" data="function_timeits.html" style="width:100%" height=650>
  <p>Figure Missing</p>
</object>
#+end_export

#+begin_src python :results output :exports both
print(TABLE(times))
#+end_src

#+RESULTS:
| Function         |     Time |
|------------------+----------|
| Heavy Hitters    |  9.52772 |
| Using List Count | 13.4807  |
| Dict List Counts | 17.3819  |
| Using Dictionary | 19.8661  |
| Using Counter    | 20.6243  |

#+begin_src python :results output :exports both
PERCENT_COLUMN = "% of Heavy Hitters"

times[PERCENT_COLUMN] = (
    times.Time /
    times[times.Function == "Heavy Hitters"].Time.iloc[0])

chart = altair.Chart(times[["Function", PERCENT_COLUMN]]).mark_bar().encode(
    x = altair.X("Function",
                 sort="-y"
                 ).axis(labelAngle=-45),
    y = PERCENT_COLUMN,
    tooltip = [altair.Tooltip("Function"),
               altair.Tooltip(PERCENT_COLUMN, format=".2f")]
    
).interactive().properties(
    title="Function Timeit Percentage of Best (Heavy Hitters)",
    width=800,
    height=525,
)

save_it(chart, "function_percentage_timeits")
#+end_src

#+RESULTS:
#+begin_export html
<object type="text/html" data="function_percentage_timeits.html" style="width:100%" height=650>
  <p>Figure Missing</p>
</object>
#+end_export

#+begin_src python :results output :exports both
print(TABLE(times))
#+end_src

#+RESULTS:
| Function         |     Time |   % of Heavy Hitters |
|------------------+----------+----------------------|
| Heavy Hitters    |  9.52772 |              1       |
| Using List Count | 13.4807  |              1.41489 |
| Dict List Counts | 17.3819  |              1.82435 |
| Using Dictionary | 19.8661  |              2.08508 |
| Using Counter    | 20.6243  |              2.16467 |

#+begin_src python :results output :exports both
TIME_COLUMN = "Time (ms)"

leet_times = pandas.DataFrame({
    "Function": ["Using Dictionary",
                 "Heavy Hitter",
                 "List Counts (with Generator)",
                 "List Counts (with List)",
                 "List Counts (one-liner)",
                 "List Counts (with dict)"],
    TIME_COLUMN: [103, 110, 100, 114, 104, 107]
})

leet_times = leet_times.sort_values(TIME_COLUMN)

chart = altair.Chart(leet_times).mark_bar().encode(
    x = altair.X("Function",
                 sort="-y",
                 type="nominal").axis(labelAngle=-45),
    y = TIME_COLUMN,
    tooltip = [altair.Tooltip("Function"),
               altair.Tooltip(TIME_COLUMN, format="d")]
    
).interactive().properties(
    title="LeetCode Function Timeit Times",
    width=800,
    height=525,
)

save_it(chart, "leetcode_timeits")
#+end_src

#+RESULTS:
#+begin_export html
<object type="text/html" data="leetcode_timeits.html" style="width:100%" height=650>
  <p>Figure Missing</p>
</object>
#+end_export


#+begin_src python :results output :exports both
print(TABLE(leet_times))
#+end_src

#+RESULTS:
| Function                     |   Time (ms) |
|------------------------------+-------------|
| List Counts (with Generator) |         100 |
| Using Dictionary             |         103 |
| List Counts (one-liner)      |         104 |
| List Counts (with dict)      |         107 |
| Heavy Hitter                 |         110 |
| List Counts (with List)      |         114 |

* Reference

-  Boyer–Moore majority vote algorithm. In: Wikipedia [Internet]. 2023 [cited 2023 Oct 9]. Available from: https://en.wikipedia.org/w/index.php?title=Boyer%E2%80%93Moore_majority_vote_algorithm&oldid=1173091113

- Misra–Gries heavy hitters algorithm. In: Wikipedia [Internet]. 2023 [cited 2023 Oct 9]. Available from: https://en.wikipedia.org/w/index.php?title=Misra%E2%80%93Gries_heavy_hitters_algorithm&oldid=1163180121

- Streaming algorithm. In: Wikipedia [Internet]. 2023 [cited 2023 Oct 9]. Available from: https://en.wikipedia.org/w/index.php?title=Streaming_algorithm&oldid=1172213699

 - https://leetcode.com/problems/majority-element-ii/ : The Majority Element Problem on LeetCode

#+begin_export html
<script>
window.addEventListener('load', function () {
    /* pseudocode.renderElement(document.getElementById("boyer-moore")); */
    pseudocode.renderClass("pseudocode");
});
</script>
#+end_export
