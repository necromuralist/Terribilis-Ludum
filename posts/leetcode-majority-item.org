#+BEGIN_COMMENT
.. title: LeetCode: Majority Item II
.. slug: leetcode-majority-item
.. date: 2023-10-06 18:06:58 UTC-05:00
.. tags: leetcode,practice
.. category: Practice
.. link: 
.. description: The "Majority Item II" problem from LeetCode.
.. type: text
.. status: 
.. updated: 
.. has_pseudocode: true
#+END_COMMENT
#+OPTIONS: ^:{}
#+TOC: headlines 2
#+PROPERTY: header-args :session ~/.local/share/jupyter/runtime/kernel-3fa2f546-e361-4fe9-a414-81ff1291e3f5-ssh.json

#+BEGIN_SRC python :results none :exports none
%load_ext autoreload
%autoreload 2
#+END_SRC
* The Problem
 - **Given:** An integer array of size /n/.
 - **Find:** All elements that appear more than $\frac{n}{3}$ times.

**Constraints:**

\[
1 \leq nums.length \leq 5 \times 10^4 \\
-10^9 \leq nums[i] \leq 10^9
\]

* Using Python Collections

1. Find $\frac{n}{3}$
2. Count all the element frequencies
3. Build a list of all the elemennts that occur frequently enough

** The Examples

These are the examples given with the problem.

#+begin_src python :results none
def frequency_floor(source: list) -> None:
    """print the n/3 for the source

    Args:
     source: collection with a length
    """
    print("n/3: {0: 2}".format(len(source)/3))
    return
#+end_src

*** Example One

#+begin_src python :results output :exports both
input_1 = [3, 2, 3]
expected_1 = [3]

frequency_floor(input_1)
#+end_src

#+RESULTS:
: n/3:  1.0

*** Example Two

#+begin_src python :results output :exports both
input_2 = [1]
expected_2 = [1]

frequency_floor(input_2)
#+end_src

#+RESULTS:
: n/3:  0.3333333333333333

*** Example Three

#+begin_src python :results output :exports both
input_3 = [1, 2]
expected_3 = [1, 2]

frequency_floor(input_3)
#+end_src

#+RESULTS:
: n/3:  0.6666666666666666

It looks like they don't expect you to use rounding.

*** Collected

#+begin_src python :results none
EXAMPLES = [(input_1, expected_1), (input_2, expected_2),
            (input_3, expected_3)]
#+end_src
** Using Counter

#+begin_src python :results none
# python
from collections import Counter
from random import randint
from timeit import timeit

import random

# pypi
from expects import contain_only, expect
#+end_src

#+begin_src python :results none
def using_counter(source: list, expected) -> list:
    """gets the output for the source

    Args:
     source: collection to filter
     expected: the expected output

    Returns:
     items in source that occur more than n/3 times
    """
    counts = Counter(source)
    lower_bound = len(source)/3
    output = [key for key, value in counts.items() if value > lower_bound]
    expect(output).to(contain_only(*expected))
    return output
#+end_src

*** Example 1
#+begin_src python :results output :exports both
print(using_counter(input_1, expected_1))
#+end_src

#+RESULTS:
: [3]

*** Example 2

#+begin_src python :results output :exports both
print(using_counter(input_2, expected_2))
#+end_src

#+RESULTS:
: [1]

*** Example 3

#+begin_src python :results output :exports both
print(using_counter(input_3, expected_3))
#+end_src

#+RESULTS:
: [1, 2]

*** Timeit

#+begin_src python :results none
def unexpected_counter(source: list) -> None:
   counts = Counter(source)
   lower_bound = len(source)/3
   output = [key for key, value in counts.items() if value > lower_bound]
   return output

for source, expected in EXAMPLES:
   expect(unexpected_counter(source)).to(contain_only(*expected))
#+end_src

#+begin_src python :results output :exports both
LIMIT = 10**9
SIZE = 10**3
CANDIDATES = 3
SOURCE = [randint(-LIMIT, LIMIT) for item in range(CANDIDATES)]
BIG_INPUT = random.choices(SOURCE, k=SIZE)
print(Counter(BIG_INPUT).most_common())
print(SIZE/3)
#+end_src

#+RESULTS:
: [(-12552546, 344), (452607266, 334), (-637442002, 322)]
: 333.3333333333333

#+begin_src python :results output :exports both
counter_time = timeit("unexpected_counter(BIG_INPUT)", globals=globals())
print("Time with Counter: {0:.2}".format(counter_time))
#+end_src

#+RESULTS:
: Time with Counter: 2e+01

#+begin_src python :results output :exports both
uncounter_time = timeit("""
counts = Counter(BIG_INPUT)
lower_bound = len(BIG_INPUT)/3
output = [key for key, value in counts.items() if value > lower_bound]
""", globals=globals())
print("Time with Un-Functioned Counter: {0:.2}".format(uncounter_time))
#+end_src

#+RESULTS:
: Time with Un-Functioned Counter: 2e+01

#+begin_src python :results output :exports both
print(counter_time - uncounter_time)
#+end_src

#+RESULTS:
: 0.08289652500025113

#+begin_src python :results output :exports both
counter_output = unexpected_counter(BIG_INPUT)
print(counter_output)
#+end_src

#+RESULTS:
: [-12552546, 452607266]

** Without Imports
#+begin_src python :results none
def without_imports(source: list, expected: list) -> list:
    """filters out items with too few occurrences

    Args:
     source: collection to filter
     expected: expected output

    Returns:
     filtered list
    """
    lower_bound = len(source)/3
    counts = {key: 0 for key in source}
    for item in source:
        counts[item] += 1

    output = [item for item, count in counts.items()
              if count > lower_bound]
    expect(output).to(contain_only(*expected))
    return output
#+end_src

*** Examples

#+begin_src python :results none
for example, expected in EXAMPLES:
    without_imports(example, expected)
#+end_src

*** Time It

#+begin_src python :results none
def unexpected_dictionary(source):
    lower_bound = len(source)/3
    counts = {key: 0 for key in source}
    
    for item in source:
        counts[item] += 1

    return [item for item, count in counts.items()
              if count > lower_bound]

for source, expected in EXAMPLES:
    expect(unexpected_dictionary(source)).to(contain_only(*expected))
#+end_src

#+begin_src python :results output :exports both
importless_time = timeit("unexpected_dictionary(BIG_INPUT)", globals=globals())
print("Time without Counter: {0:.2}".format(importless_time))
#+end_src

#+RESULTS:
: Time without Counter: 2.7e+01

#+begin_src python :results output :exports both
print(counter_time - importless_time)
unexpected_output = unexpected(BIG_INPUT)
expect(unexpected_output).to(contain_only(*counter_output))
#+end_src

#+RESULTS:
: 0.7523003370151855

Strangely this was a little faster. When I originally ran this there were a lot of different numbers in the ~BIG_INPUT~ and the ~Counter~ version was faster, but with only three they're pretty much the same. But, when there were a lot of different numbers, since the ~random.choices~ is using a uniform distribution there was also never a value that had occured more than a third of the time in the list either, so it wasn't really a good input.

* Majority Vote and Heavy Hitters Algorithms

On the discussion board for [[https://leetcode.com/problems/majority-element-ii/][the Majority Element II problem on LeetCode]] there's several people who mention the [[https://en.wikipedia.org/w/index.php?title=Boyer%E2%80%93Moore_majority_vote_algorithm&oldid=1173091113][Boyer-Moore Majority Vote Algorithm]] which is a [[https://en.wikipedia.org/w/index.php?title=Streaming_algorithm&oldid=1172213699][Streaming Algorithm]]
to find the element with the majority of the places in a sequence. Since it's a streaming algorithm it doesn't build a dictionary (or Counter) like I did but instead uses two passes over the sequence keeping the majority element in a variable. This is the algorithm given on Wikipedia.

#+begin_export html
<pre id="boyer-moore" class="pseudocode">
\begin{algorithm}
\caption{Boyer-Moore Majority Voting Algorithm}
\begin{algorithmic}
\INPUT A collection of votes with a candidate with the majority of votes
\OUTPUT The candidate that might have the majority
\PROCEDURE{MajorityVote}{\textit{votes}}
  \STATE \textit{lead} $\gets 0$
  \STATE \textit{candidate} $\gets$ \textit{None}
  \FOR {\textit{vote} $\in$ \textit{votes}}
   \IF {\textit{lead = 0}}
    \STATE \textit{candidate} $\gets$ \textit{vote}
    \STATE \textit{lead} $\gets 1$
  \ELSEIF {\textit{candidate = vote}}
    \STATE \textit{lead} $\gets$ \textit{lead + 1}
  \ELSE
    \STATE \textit{lead} $\gets$ \textit{lead - 1}
   \ENDIF
  \ENDFOR
\RETURN \textit{candidate}
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
</pre>
#+end_export

**Note to self:** There is some kind of race-condition going on between ~pseudocode.js~ and ~MathJax~ which causes the math to not be rendered some times. Reloading the page or emptying the browser cache seems to fix it.

An important thing to note is that this only works if one of the candidates has more than half of the votes (the majority), not necessarily the most votes. If none of the candidates has more than half of the votes it might return not just the highest vote getter but any candidate. Consider this set.

\[
\{A, A, B, B, C, A\}
\]

| Vote | Candidate | Lead |
|------+-----------+------|
| A    | A         |    1 |
| A    | A         |    2 |
| B    | A         |    1 |
| B    | A         |    0 |
| C    | C         |    1 |
| A    | C         | 0    |

A has the most votes, but not greater than half and it ends up returning C as the leading candidate. Adding another A in there at any point would give it the majority and we would always return A.

One way to think of it is to consider that when the lead goes to zero it is essentially the same as resetting the algorithm and starting at the next vote - if the count goes to 0, none of the candidates had more votes than any other up to that point, so if there is an element that has the majority it will have to have it in the votes that follow. But if the candidate with the most votes doesn't have more than half of the total then it's possible that the other votes will negate it before reaching the end and we end up choosing the wrong candidate as the winner.

Another thing to note is that we are keeping a single counter so we don't know how many votes the eventual winner got. We could start a counter when a candidate takes the lead, but unless the eventual winner is always in the lead we'd end up skipping votes everytime the lead went to 0 and the leading candidate was swapped out.

So why not keep counts for all the candidates? That's what I did with the Counter and dict versions of our /Majority Items/ problem, but the Streaming Algorithms are meant to solve problems using a minimum of memory, something that the collections don't do. So instead, once we find our leading candidate on our first pass through the votes, we need to run a second pass to count up the number of votes the chosen candidate got to make sure it was the majority. If it wasn't, then the algorithm won't work so we don't have an answer.

** The Misra-Gries Heavy-Hitters Algorithm

One thing noticeable about the Boyer-Moore Voting Algorithm is that since it only works if one candidate gets more than half of the votes, then it doesn't really work for our problem, since we're looking for the candidates that get more than a third of the votes. The Heavy Hitters problem is an extension of the Majority Vote problem where instead of finding the candidate with more than half of the votes we find all candidates with greater than \(^n/_k\)votes where \(k \geq 2\) and the /Misra-Gries Heavy Hitters Algorithm/ is one way to solve it.

It works by maintaining a collection (/bag/) that holds the votes for the candidates that might have greater than \(^n/_k\) votes. This might seem like we're back to where we were with the dict, but the way the algorithm is constructed, the collection never holds more than /k/ distinct candidates (although it does keep track of their votes). Like the Boyer-Moore algorithm the Misra-Gries algorithm needs a seconds pass to determine which candidates actually have enough votes to be a heavy-hitter.

The output of the first pass is useful by itself, even if it doesn't completely solve the Heavy-Hitters problem, since it's constructed in a way so that the collection we're making will have the /k - 1/ candidates with the most votes.

Here's my slight re-wording of the algorithm as given on wikipedia.

#+begin_export html
<pre id="misra-gries" class="pseudocode">
\begin{algorithm}
\caption{Misra-Gries Heavy-Hitter Algorithm}
\begin{algorithmic}
\INPUT A collection of \textit{votes}
\INPUT $k$, the upper limit for candidates to output
\OUTPUT The $k - 1$ candidates that might be heavy hitters
\PROCEDURE{HeavyHitters}{\textit{votes}}
  \STATE \textit{distinct} $\gets 0$
  \STATE \textit{candidates} $\gets$ \{\}
  \FOR {\textit{vote} $\in$ \textit{votes}}
  
    \STATE Add \textit{candidate} to \textit{candidates}
    
    \IF {\textit{candidate} $\notin$ \textit{candidates}}
      \STATE \textit{distinct = distinct + 1}
   \ENDIF

   \IF {\textit{distinct} = $k$}
      \STATE Remove $k$ distinct elements from \textit{candidates}
      \STATE Update \textit{distinct}
   \ENDIF
  \ENDFOR
\RETURN \textit{candidates}
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
</pre>
#+end_export

So, here's some things to note about the algorithm:

 - $\textit{distinct}$ is the number of unique canditates in $\textit{candidates}$ (we're adding each vote so $candidates$ is larger than $\textit{distinct})$
 - $\textit{distinct}$ only gets incremented when we encounter a new candidate, and if $\textit{distinct} = k$ when we remove $k$ elements from $\textit{candidates}$ the last candidate only has one entry, so it gets removed
 - Update $\textit{distinct}$ is a little vague
 - Since we're storing all votes, doesn't that mean we're going to use a lot of memory? Why not just go with the earlier non-streaming solutions?

The answer to the vagueness of /Update distinct/ and the size of our /candidates/ is that we don't implement it exactly this way (and there's more than one way to implement it). Instead of storing all the votes, we can just store the counts of the votes (since that's all we care about anyway) along with the value that's being counted. Then we remove any value/count pair where the count has dropped to zero and reduce /distinct/ when we do. Since key-value pairs are natural for a dictionary we could implement it that way, knowing that it won't have more than /k-1/ keys and more than one value each.

An even better solution might be to create a collection of ( candidate, count ) tuples, but for our particular problem, there's an even better way.

* Reference

-  Boyer–Moore majority vote algorithm. In: Wikipedia [Internet]. 2023 [cited 2023 Oct 9]. Available from: https://en.wikipedia.org/w/index.php?title=Boyer%E2%80%93Moore_majority_vote_algorithm&oldid=1173091113

- Misra–Gries heavy hitters algorithm. In: Wikipedia [Internet]. 2023 [cited 2023 Oct 9]. Available from: https://en.wikipedia.org/w/index.php?title=Misra%E2%80%93Gries_heavy_hitters_algorithm&oldid=1163180121

- Streaming algorithm. In: Wikipedia [Internet]. 2023 [cited 2023 Oct 9]. Available from: https://en.wikipedia.org/w/index.php?title=Streaming_algorithm&oldid=1172213699

 - https://leetcode.com/problems/majority-element-ii/ : The Majority Element Problem on LeetCode

#+begin_export html
<script>
window.addEventListener('load', function () {
    /* pseudocode.renderElement(document.getElementById("boyer-moore")); */
    pseudocode.renderClass("pseudocode");
});
</script>
#+end_export
